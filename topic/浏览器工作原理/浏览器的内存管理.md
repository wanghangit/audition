# 内存管理

## 在js引擎中的几种内存空间

1. 代码运行空间 进入一个函数的调用就会创建一个上下文执行环境，并推入浏览器的调用栈，离开函数的调用会销毁这个上下文环境
2. 栈空间 用来存贮各种基本数据类型
3. 堆空间 用来保存引用数据类型也就`Object`类型

为什么要这样存贮数据，因为存贮在栈中的数据当离开栈时会被销毁，基本数据占用的空间比较小，而引用数据类型栈中存贮的只是引用，类似指针，堆的空间比较大，减少了频繁创建销毁带来不必要的开销

## 垃圾如何回收

### 栈中的数据如何回收

当进入一个函数时会创建一个上下文环境，当离开这个函数时，会将栈中的基本数据类型都清除

### 堆中的数据如何回收

这个问题比栈中的回收要复杂一些，堆中存贮的数据一般都比较大，采用了类似jvm的垃圾回收机制，采用了代际假说理论

1. 大部分对象在内存中的时间很短
2. 不死的对象，会存活的越来越久

基于代际假说，引擎将垃圾回收区域分为2个区域，新生代和老生代

#### 清理过程

对于这两个生代，有主和副垃圾回收器流程都一样

1. 标记活动对象和非活动对象
2. 清理非活动对象
3. 对内存进行整理（主要是对主垃圾回收器）

#### 新生代

新生代中存放生存时间短的对象，一般空间比较小，1M到8M
垃圾回收器会分为2个区域，空闲区域和对象区域，新的对象会加到空闲区域，当空闲区域满了就会一次性复制到对象区域进行垃圾回收
可以看到这样新生代空间会越来越大，采用晋升策略，当经历2次垃圾回收还没有回收掉就会进入老生代

#### 老生代

老生代中存放生存时间久的对象，空间比较大，采用对是标记清除算法，将标记不在引用的对象删除，然后整理碎片空间，留出来连续的内存空间使用

#### 清除策略

当执行一次老生代的垃圾回收需要执行的时间比较长，如果一次性执行可能造成卡顿，所以采用分段清除的策略，将垃圾回收和js代码交替执行，保持页面的正常运行

