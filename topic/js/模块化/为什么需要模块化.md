# 模块化的历史及原因

我们在写代码时，基于不同功能我们通常将功能封装成函数

```js
function add(a,b){
  return a+b
}
function less(a,b){
  return a-b
}
```

例如上边这样但是会造成全局变量的污染

基于IFEE实现了模块化的基础，这样实现将不想暴露的对象隐藏起来，实现了封装的概念

```js
(function(window){
  var data = 'inner'
  function bar(){
    console.log(`data is ${data}`)
  }
  window.myModule = { bar }
})(window)
```

## CommonJs模块

1. 概述
在node端默认使用的模块加载机制，在服务端由于读取本地的文件所以是同步加载的，在浏览器端需要先编译再使用

2. 加载机制
commonjs输出的是值的拷贝不是引用,多次引用文件只会被加载一次，第一次加载会缓存起来

```js
// lib.js
var counter = 3;
function incCounter() {
  counter++;
}
module.exports = {
  counter: counter,
  incCounter: incCounter,
};
// main.js
var counter = require('./lib').counter;
var incCounter = require('./lib').incCounter;
console.log(counter);  // 3
incCounter();
console.log(counter); // 3
```

lib内部的值变化不会影响`main.js`中的counter

## AMD

在服务端使用同步加载没有问题，但是在浏览器端同步加载会将降低页面性能，